"use strict";const path=require("path"),fs=require("fs"),DEFAULT_CONFIG_FILE_NAME="config.json";async function loadConfig(e){let t,r;try{e=findValidConfigFilePath(e),r=path.dirname(e)}catch(e){return Promise.reject(e)}try{const r=fs.readFileSync(e);t=JSON.parse(r)}catch(e){return Promise.reject(["Failed to parse config file:","=>",e,"<="])}if("include"in(t=resolveConfigPaths(r,t))){const e=[],r=[];for(const n of t.include)try{const t=await loadConfig(n);r.push(t)}catch(t){e.push(t)}if(e.length>0)return Promise.reject(["Failed to resolve config includes:","=>",e,"<="]);const n=r.reduce((e,t)=>mergeConfigs(t,e),{});t=mergeConfigs(t,n)}return t}function findValidConfigFilePath(e){if(!fs.existsSync(e))throw new Error(`Cannot find non-existant path '${e}'.`);if(fs.lstatSync(e).isDirectory()){const t=e;if(e=path.resolve(t,DEFAULT_CONFIG_FILE_NAME),!fs.existsSync(e))throw new Error(`Cannot find config file in directory '${t}'.`)}return e}function resolveConfigEntry(e,t,r){if(t.toLowerCase().endsWith("path"))return resolveConfigPathEntry(e,r);if(Array.isArray(r)){let t=[];for(const n in r)t.push(resolveConfigEntry(e,n,r[n]));return t}if("object"==typeof r){let t={};for(const[n,a]of Object.entries(r))t[n]=resolveConfigEntry(e,n,a);return t}return r}function resolveConfigPathEntry(e,t){if(Array.isArray(t)){let r=[];for(const n of t)r.push(resolveConfigPathEntry(e,n));return r}return"object"==typeof t?resolveConfigPaths(e,t):"string"==typeof t?path.resolve(e,t):t}function resolveConfigPaths(e,t){const r=resolveConfigEntry(e,"",t);return"include"in t&&Array.isArray(t.include)&&(r.include=t.include.map(t=>resolveConfigPathEntry(e,t))),r}function mergeConfigs(e,t){for(const[r,n]of Object.entries(e))r in t?Array.isArray(t[r])&&(Array.isArray(n)?t[r]=t[r].concat(n):t[r].push(n)):t[r]=e[r];return t}async function askForConfigFilePath(e){return null}async function askWhetherDatabaseIsValidToUse(e,t){return!0}async function loadConfigFile(e){return console.log("...Load config..."),await loadConfig(e)}async function requestConfigFile(e){return console.log("...Request config..."),await askForConfigFilePath()}async function loadDefaultConfig(e){return console.log("...Load default config..."),{inputs:[],outputs:[]}}const ONE_DAYTIME=864e5;function compareDates(e,t){return e.getTime()-t.getTime()}function getPastSunday(e,t=0){const r=new Date(e.getTime());return r.setUTCDate(r.getUTCDate()-r.getUTCDay()+t),r}function getNextSunday(e,t=0){const r=new Date(e.getTime());return r.setUTCDate(r.getUTCDate()-r.getUTCDay()+7+t),r}function getNextEffectiveSunday(e,t=0){return e.getUTCDay()>t?getNextSunday(new Date(e.getTime()+7*ONE_DAYTIME)):getNextSunday(e)}const ONE_DAYTIME$1=864e5;function createSchedule(e,t,r={}){const n=r.threshold||0,a=ONE_DAYTIME$1*n,o=getNextEffectiveSunday(e,n),s=t.getTime()-a,i=getPastSunday(e),u=new Date(i.getTime());let c=0;for(;u.getTime()<s;)u.setUTCDate(u.getUTCDate()+7),++c;return{startDate:e,endDate:t,weeks:c,startSunday:i,firstSunday:o,lastSunday:u}}function createUser(e,t,r,n,a,o,s){return{id:e,ownerKey:t,name:r,schedule:createSchedule(n,a,o),attributes:s}}const USER_KEY="user";function setupDatabase(e){return USER_KEY in e||(e[USER_KEY]=new Map),e}function addUser(e,t,r,n,a,o,s,i={}){const u=e[USER_KEY];if(u.has(t))return e.throwError(USER_KEY,`Found duplicate id for user '${t}'.`),null;{const e=createUser(t,r,n,a,o,s,i);return u.set(t,e),e}}const fs$1=require("fs"),path$1=require("path"),readline=require("readline"),Papa=require("papaparse");function readCSVFileByRow(e,t){return new Promise((r,n)=>{const a=fs$1.createReadStream(e);Papa.parse(a,{step:e=>t(e.data),complete:r,error:n})})}function parseDate(e){const t=new Date(1e3),r=Number(e.substring(0,4)),n=Number(e.substring(5,7)),a=Number(e.substring(8,10)),o=Number(e.substring(11,13)),s=Number(e.substring(14,16)),i=Number(e.substring(17,19));if(NaN===r||NaN===n||NaN===a||NaN===o||NaN===s||NaN===i)throw new Error("Invalid date format - should be YYYY-MM-DD HH:MM:SS.");return t.setUTCFullYear(r),t.setUTCMonth(n-1),t.setUTCDate(a),t.setUTCHours(o),t.setUTCMinutes(s),t.setUTCSeconds(i),t}function parseAmericanDate(e){const t=new Date(1e3),r=e.split("/"),n=Number(r[2]),a=Number(r[0]),o=Number(r[1]);if(NaN===n||NaN===a||NaN===o)throw new Error("Invalid date format - should be MM/DD/YYYY.");return t.setUTCFullYear(n),t.setUTCMonth(a-1),t.setUTCDate(o),t}function parseName(e){return e}function parseEmail(e,...t){const r=e.split(",").map(e=>{if(e)return e.trim().toLowerCase()});if(t.length>0)for(const e of t){const t=parseEmail(e);if(Array.isArray(t))for(const e of t)r.push(e);else r.push(t)}return 1===r.length?r[0]:r}async function parse(e,t,r,n={threshold:2}){setupDatabase(e);let a=!0;return await readCSVFileByRow(r,t=>{if(a)a=!1;else try{const r=parseEmail(t[6]),a=parseEmail(t[6],t[1]),o=parseName(`${t[3]} ${t[2]}`),s=t[5].trim().toUpperCase(),i=parseAmericanDate(t[11]),u=parseAmericanDate(t[12]);addUser(e,r,a,o,i,u,n,{pid:s})}catch(t){e.throwError("PARSE","Unable to parse users - "+t)}}),e}var CohortParser=Object.freeze({parse:parse});function createSubmission(e,t,r,n,a={}){return{id:e,owner:t,assignment:r,date:n,attributes:a}}const SUBMISSION_KEY="submission",SUBMISSION_OWNER_KEY="owner",SUBMISSION_LIST_KEY="list";function setupDatabase$1(e){SUBMISSION_KEY in e||(e[SUBMISSION_KEY]={});const t=e[SUBMISSION_KEY];return SUBMISSION_OWNER_KEY in t||(t[SUBMISSION_OWNER_KEY]=new Map),SUBMISSION_LIST_KEY in t||(t[SUBMISSION_LIST_KEY]=new Map),e}function addSubmission(e,t,r,n,a,o={}){const s=e[SUBMISSION_KEY],i=s[SUBMISSION_OWNER_KEY],u=s[SUBMISSION_LIST_KEY];if(u.has(t))return e.throwError(SUBMISSION_KEY,`Found duplicate id for submission '${t}'.`),null;{Array.isArray(r)&&(r=r[0]);const e=createSubmission(t,r,n,a,o);let s=i.get(r);return s||i.set(r,s={}),addSubmissionToAssignment(e,n,s),u.set(t,e),e}}function addSubmissionToAssignment(e,t,r){if(e.assignment=t,t in r){const n=r[t];let a=0;for(;a<n.length&&!(compareDates(e.date,n[a].date)<0);++a);n.splice(a,0,e)}else r[t]=[e];return e}function stringHash(e=""){let t=0;for(let r=0,n=e.length;r<n;r++)t=Math.imul(31,t)+e.charCodeAt(r)|0;return t}function evaluatePostAssignment(e,t){if(/intro/i.test(e))return"intro";{const t=/week ?([0-9]+)/i.exec(e);if(t&&t.length>0)return"0"==t[1]?"intro":"week["+Number.parseInt(t[1])+"]"}return/last/i.test(e)?"last":"null"}async function parse$1(e,t,r,n={}){setupDatabase$1(e);let a=!0;return await readCSVFileByRow(r,t=>{if(a)a=!1;else try{const r=t[7];if("followup"===r||"reply_to_followup"===r||"started_off_i_answer"===r||"updated_i_answer"===r||"started_off_s_answer"===r||"updated_s_answer"===r)return;const n=parseEmail(t[9]),a=parseDate(t[3]),o=t[1],s=(Array.isArray(n)?n[0]:n)+"#"+o+"_"+stringHash(t[3]),i=evaluatePostAssignment(t[6],t[5]),u={content:{head:t[6],body:t[5],id:o}};addSubmission(e,s,n,i,a,u)}catch(t){e.throwError("PARSE","Unable to parse submissions - "+t)}}),e}var ContributionsParser=Object.freeze({parse:parse$1});async function findInputEntries(e){return Array.isArray(e.inputs)?e.inputs:[]}async function loadInputEntry(e,t,r){const n=r.filePath,a=r.parser,o=r.customParserPath,s=r.opts;let i;if(o)try{if("function"!=typeof(i=require(o)).parse)throw new Error(`Invalid custom parser '${o}' - must export named function 'parse'.`)}catch(e){throw new Error(`Cannot load custom parser from '${o}'.`,e)}else switch(a){case"cohort":i=CohortParser;break;case"contributions":i=ContributionsParser;break;default:throw new Error(`Cannot find valid parser of type '${a}'.`)}await i.parse(e,t,n,s)}function createDatabase(){return{_registry:{},_errors:new Map,throwError(e,t,r={}){let n;n="object"==typeof r&&"id"in r?Array.isArray(r.id)?stringHash(r.id.join(".")):"number"!=typeof r.id?stringHash(JSON.stringify(r.id)):r.id:this._errors.size;let a=1e3;for(;a-- >=0&&this._errors.has(n);)++n;if(a<=0)throw new Error("Invalid error id - too many errors.");const o={id:n,tag:e,message:t,options:[],more:[],toString:()=>`${n} [${e}] ${t}`};if("string"==typeof r)o.options.push(r);else if("object"==typeof r){if("options"in r)if(Array.isArray(r.options))for(const e of r.options)o.options.push(e);else o.options.push(option);"more"in r&&(o.more=r.more)}this._errors.set(n,o)},getErrorByID(e){return this._errors.get(e)},clearErrors(){this._errors.clear()},getErrors(){return Array.from(this._errors.values())}}}const ASSIGNMENT_KEY="assignment";function setupDatabase$2(e){return ASSIGNMENT_KEY in e||(e[ASSIGNMENT_KEY]=new Map),e}const REVIEW_KEY="review";function setupDatabase$3(e){return REVIEW_KEY in e||(e[REVIEW_KEY]=new Map),e}const VACATION_KEY="vacation";function setupDatabase$4(e){return VACATION_KEY in e||(e[VACATION_KEY]=new Map),e}async function setupDatabase$5(e){const t=createDatabase();let r;return r="currentDate"in e?parseAmericanDate(e.currentDate):new Date(Date.now()),t.currentDate=r,setupDatabase(t),setupDatabase$1(t),setupDatabase$2(t),setupDatabase$3(t),setupDatabase$4(t),t}async function createDatabase$1(e){return console.log("...Creating database..."),await setupDatabase$5(e)}async function loadDatabaseFromInputs(e,t){console.log("...Load database from inputs...");const r=await findInputEntries(t);for(const n of r)try{await loadInputEntry(e,t,n)}catch(e){console.error("Failed to load input entry.",e)}}async function verifyDatabaseWithClient(e,t){return console.log("...Verifying database with client..."),await askWhetherDatabaseIsValidToUse()}async function findDatabaseErrors(e,t){console.log("...Finding database errors...")}async function shouldContinueResolvingErrorsWithClient(e,t,r){console.log("...Should resolve database errors?")}async function resolveDatabaseErrors(e,t,r){console.log("...Resolving database errors...")}async function verifyErrorsWithClient(e,t,r){if(!r||r.length<=0)return!0}async function outputErrorLog(e,t,r){console.log("...Outputting database errors...")}function findOutputEntries(e){return console.log("...Finding output entries..."),Array.isArray(e.outputs)?e.outputs:[]}function processOutputEntry(e,t,r){console.log("...Process output entry...")}const DIRECTORY=".";async function main(e){try{const e=await resolveConfig(DIRECTORY);console.log(e);const t=await resolveDatabase(e);console.log(t),await validateDatabase(t,e),await generateOutput(t,e)}catch(e){return console.error("Program failed.",e),!1}return!0}async function resolveConfig(e){let t;console.log("Resolving config...");try{t=await loadConfigFile(e)}catch(e){let r;for(;r=await requestConfigFile();)try{if(t=await loadConfigFile(r))break}catch(e){console.error("Failed to load config.",e)}t||(t=await loadDefaultConfig())}if(!t)throw new Error("Could not resolve a config file for program. Stopping program...");return t}async function resolveDatabase(e){console.log("Resolving database...");const t=await createDatabase$1(e);if(await loadDatabaseFromInputs(t,e),!await verifyDatabaseWithClient())throw new Error("Could not resolve database for program. Please update the config to match your specifications, then try again. Stopping program...");return t}async function validateDatabase(e,t){let r;for(console.log("Validating database...");(r=await findDatabaseErrors())&&await shouldContinueResolvingErrorsWithClient();)await resolveDatabaseErrors();if(!await verifyErrorsWithClient(e,t,r))throw await outputErrorLog(),new Error("Could not validate database. Stopping program...")}async function generateOutput(e,t){console.log("Generating output...");const r=findOutputEntries(t);for(const n of r)try{processOutputEntry(e,t,n)}catch(e){console.error("Failed to process output entry.",e)}}main(process.argv).then(e=>{e?console.log("Success!"):console.log("Failure!")});
