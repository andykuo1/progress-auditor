"use strict";const path=require("path"),fs=require("fs"),DEFAULT_CONFIG_FILE_NAME="config.json";async function loadConfig(t){let e,r;try{t=findValidConfigFilePath(t),r=path.dirname(t)}catch(t){return Promise.reject(t)}try{const r=fs.readFileSync(t);e=JSON.parse(r)}catch(t){return Promise.reject(["Failed to parse config file:","=>",t,"<="])}if("include"in(e=resolveConfigPaths(r,e))){const t=[],r=[];for(const n of e.include)try{const e=await loadConfig(n);r.push(e)}catch(e){t.push(e)}if(t.length>0)return Promise.reject(["Failed to resolve config includes:","=>",t,"<="]);const n=r.reduce((t,e)=>mergeConfigs(e,t),{});e=mergeConfigs(e,n)}return e}function findValidConfigFilePath(t){if(!fs.existsSync(t))throw new Error(`Cannot find non-existant path '${t}'.`);if(fs.lstatSync(t).isDirectory()){const e=t;if(t=path.resolve(e,DEFAULT_CONFIG_FILE_NAME),!fs.existsSync(t))throw new Error(`Cannot find config file in directory '${e}'.`)}return t}function resolveConfigEntry(t,e,r){if(e.toLowerCase().endsWith("path"))return resolveConfigPathEntry(t,r);if(Array.isArray(r)){let e=[];for(const n in r)e.push(resolveConfigEntry(t,n,r[n]));return e}if("object"==typeof r){let e={};for(const[n,s]of Object.entries(r))e[n]=resolveConfigEntry(t,n,s);return e}return r}function resolveConfigPathEntry(t,e){if(Array.isArray(e)){let r=[];for(const n of e)r.push(resolveConfigPathEntry(t,n));return r}return"object"==typeof e?resolveConfigPaths(t,e):"string"==typeof e?path.resolve(t,e):e}function resolveConfigPaths(t,e){const r=resolveConfigEntry(t,"",e);return"include"in e&&Array.isArray(e.include)&&(r.include=e.include.map(e=>resolveConfigPathEntry(t,e))),r}function mergeConfigs(t,e){for(const[r,n]of Object.entries(t))r in e?Array.isArray(e[r])&&(Array.isArray(n)?e[r]=e[r].concat(n):e[r].push(n)):e[r]=t[r];return e}async function askForConfigFilePath(t){return null}async function askWhetherDatabaseIsValidToUse(t,e){return!0}async function loadConfigFile(t){return console.log("...Load config..."),await loadConfig(t)}async function requestConfigFile(t){return console.log("...Request config..."),await askForConfigFilePath()}async function loadDefaultConfig(t){return console.log("...Load default config..."),{inputs:[],outputs:[]}}const ONE_DAYTIME=864e5;function compareDates(t,e){return t.getTime()-e.getTime()}function getPastSunday(t,e=0){const r=new Date(t.getTime());return r.setUTCDate(r.getUTCDate()-r.getUTCDay()+e),r}function getNextSunday(t,e=0){const r=new Date(t.getTime());return r.setUTCDate(r.getUTCDate()-r.getUTCDay()+7+e),r}function getNextEffectiveSunday(t,e=0){return t.getUTCDay()>e?getNextSunday(new Date(t.getTime()+7*ONE_DAYTIME)):getNextSunday(t)}const ONE_DAYTIME$1=864e5;function calculateNumberOfSlipDays(t){return 3*t.weeks}function createSchedule(t,e,r={}){const n=r.threshold||0,s=ONE_DAYTIME$1*n,o=getNextEffectiveSunday(t,n),a=e.getTime()-s,i=getPastSunday(t),u=new Date(i.getTime());let c=0;for(;u.getTime()<a;)u.setUTCDate(u.getUTCDate()+7),++c;return{startDate:t,endDate:e,weeks:c,startSunday:i,firstSunday:o,lastSunday:u}}function createUser(t,e,r,n,s,o,a){return{id:t,ownerKey:e,name:r,schedule:createSchedule(n,s,o),attributes:a}}const USER_KEY="user",OUTPUT_LOG="db.user.log";function setupDatabase(t){return USER_KEY in t||(t[USER_KEY]=new Map),t}function addUser(t,e,r,n,s,o,a,i={}){const u=t[USER_KEY];if(u.has(e))return t.throwError(USER_KEY,`Found duplicate id for user '${e}'.`),null;{const t=createUser(e,r,n,s,o,a,i);return u.set(e,t),t}}function getUsers(t){return t[USER_KEY].keys()}function getUserByID(t,e){return t[USER_KEY].get(e)}function outputLog(t,e="."){const r=t[USER_KEY],n={};for(const[t,e]of r.entries())n[t]=e;const s=`${`${"# ".repeat(20)}\n# Users\n# Size: ${r.size}\n${"# ".repeat(20)}`}\n${JSON.stringify(n,null,4)}`;require("fs").writeFileSync(require("path").resolve(e,OUTPUT_LOG),s)}const fs$1=require("fs"),path$1=require("path"),readline=require("readline"),Papa=require("papaparse");function readCSVFileByRow(t,e){return new Promise((r,n)=>{const s=fs$1.createReadStream(t);Papa.parse(s,{step:t=>e(t.data),complete:r,error:n})})}function writeToFile(t,e){fs$1.mkdirSync(path$1.dirname(t),{recursive:!0}),fs$1.writeFile(t,e,function(e){if(e)return console.log(e);console.log("File saved:",t)})}function writeTableToCSV(t,e){writeToFile(t,e.map(t=>t.join(",")).join("\n"))}function parseDate(t){const e=new Date(1e3),r=Number(t.substring(0,4)),n=Number(t.substring(5,7)),s=Number(t.substring(8,10)),o=Number(t.substring(11,13)),a=Number(t.substring(14,16)),i=Number(t.substring(17,19));if(NaN===r||NaN===n||NaN===s||NaN===o||NaN===a||NaN===i)throw new Error("Invalid date format - should be YYYY-MM-DD HH:MM:SS.");return e.setUTCFullYear(r),e.setUTCMonth(n-1),e.setUTCDate(s),e.setUTCHours(o),e.setUTCMinutes(a),e.setUTCSeconds(i),e}function parseAmericanDate(t){const e=new Date(1e3),r=t.split("/"),n=Number(r[2]),s=Number(r[0]),o=Number(r[1]);if(NaN===n||NaN===s||NaN===o)throw new Error("Invalid date format - should be MM/DD/YYYY.");return e.setUTCFullYear(n),e.setUTCMonth(s-1),e.setUTCDate(o),e}function parseName(t){return t}function parseEmail(t,...e){const r=t.split(",").map(t=>{if(t)return t.trim().toLowerCase()});if(e.length>0)for(const t of e){const e=parseEmail(t);if(Array.isArray(e))for(const t of e)r.push(t);else r.push(e)}return 1===r.length?r[0]:r}async function parse(t,e,r,n={threshold:2}){setupDatabase(t);let s=!0;return await readCSVFileByRow(r,e=>{if(s)s=!1;else try{const r=parseEmail(e[6]),s=parseEmail(e[6],e[1]),o=parseName(`${e[3]} ${e[2]}`),a=e[5].trim().toUpperCase(),i=parseAmericanDate(e[11]),u=parseAmericanDate(e[12]);addUser(t,r,s,o,i,u,n,{pid:a})}catch(e){t.throwError("PARSE","Unable to parse users - "+e)}}),t}var CohortParser=Object.freeze({parse:parse});function createSubmission(t,e,r,n,s={}){return{id:t,owner:e,assignment:r,date:n,attributes:s}}const SUBMISSION_KEY="submission",SUBMISSION_OWNER_KEY="owner",SUBMISSION_LIST_KEY="list",OUTPUT_LOG$1="db.submission.log";function setupDatabase$1(t){SUBMISSION_KEY in t||(t[SUBMISSION_KEY]={});const e=t[SUBMISSION_KEY];return SUBMISSION_OWNER_KEY in e||(e[SUBMISSION_OWNER_KEY]=new Map),SUBMISSION_LIST_KEY in e||(e[SUBMISSION_LIST_KEY]=new Map),t}function addSubmission(t,e,r,n,s,o={}){const a=t[SUBMISSION_KEY],i=a[SUBMISSION_OWNER_KEY],u=a[SUBMISSION_LIST_KEY];if(u.has(e))return t.throwError(SUBMISSION_KEY,`Found duplicate id for submission '${e}'.`),null;{Array.isArray(r)&&(r=r[0]);const t=createSubmission(e,r,n,s,o);let a=i.get(r);return a||i.set(r,a={}),addSubmissionToAssignment(t,n,a),u.set(e,t),t}}function addSubmissionToAssignment(t,e,r){if(t.assignment=e,e in r){const n=r[e];let s=0;for(;s<n.length&&!(compareDates(t.date,n[s].date)<0);++s);n.splice(s,0,t)}else r[e]=[t];return t}function outputLog$1(t,e="."){const r=t[SUBMISSION_KEY][SUBMISSION_OWNER_KEY],n=t[SUBMISSION_KEY][SUBMISSION_LIST_KEY],s={owner:{},list:{}};for(const[t,e]of r.entries())s.owner[t]=e;for(const[t,e]of n.entries())s.list[t]=e;const o=`${`${"# ".repeat(20)}\n# Submissions\n# Size: ${n.size}\n${"# ".repeat(20)}`}\n${JSON.stringify(s,null,4)}`;require("fs").writeFileSync(require("path").resolve(e,OUTPUT_LOG$1),o)}function stringHash(t=""){let e=0;for(let r=0,n=t.length;r<n;r++)e=Math.imul(31,e)+t.charCodeAt(r)|0;return e}function evaluatePostAssignment(t,e){if(/intro/i.test(t))return"intro";{const e=/week ?([0-9]+)/i.exec(t);if(e&&e.length>0)return"0"==e[1]?"intro":"week["+Number.parseInt(e[1])+"]"}return/last/i.test(t)?"last":"null"}async function parse$1(t,e,r,n={}){setupDatabase$1(t);let s=!0;return await readCSVFileByRow(r,e=>{if(s)s=!1;else try{const r=e[7];if("followup"===r||"reply_to_followup"===r||"started_off_i_answer"===r||"updated_i_answer"===r||"started_off_s_answer"===r||"updated_s_answer"===r)return;const n=parseEmail(e[9]),s=parseDate(e[3]),o=e[1],a=(Array.isArray(n)?n[0]:n)+"#"+o+"_"+stringHash(e[3]),i=evaluatePostAssignment(e[6],e[5]),u={content:{head:e[6],body:e[5],id:o}};addSubmission(t,a,n,i,s,u)}catch(e){t.throwError("PARSE","Unable to parse submissions - "+e)}}),t}var ContributionsParser=Object.freeze({parse:parse$1});async function findInputEntries(t){return console.log("...Finding input entries..."),Array.isArray(t.inputs)?t.inputs:[]}async function loadInputEntry(t,e,r){console.log("...Process input entry...");const n=r.filePath,s=r.parser,o=r.customParserPath,a=r.opts;let i;if(o)try{if("function"!=typeof(i=require(o)).parse)throw new Error(`Invalid custom parser '${o}' - must export named function 'parse'.`)}catch(t){throw new Error(`Cannot load custom parser from '${o}'.`,t)}else switch(s){case"cohort":i=CohortParser;break;case"contributions":i=ContributionsParser;break;default:throw new Error(`Cannot find valid parser of type '${s}'.`)}await i.parse(t,e,n,a)}function createDatabase(){return{_registry:{},_errors:new Map,throwError(t,e,r={}){let n;n="object"==typeof r&&"id"in r?Array.isArray(r.id)?stringHash(r.id.join(".")):"number"!=typeof r.id?stringHash(JSON.stringify(r.id)):r.id:this._errors.size;let s=1e3;for(;s-- >=0&&this._errors.has(n);)++n;if(s<=0)throw new Error("Invalid error id - too many errors.");const o={id:n,tag:t,message:e,options:[],more:[],toString:()=>`${n} [${t}] ${e}`};if("string"==typeof r)o.options.push(r);else if("object"==typeof r){if("options"in r)if(Array.isArray(r.options))for(const t of r.options)o.options.push(t);else o.options.push(option);"more"in r&&(o.more=r.more)}this._errors.set(n,o)},getErrorByID(t){return this._errors.get(t)},clearErrors(){this._errors.clear()},getErrors(){return Array.from(this._errors.values())}}}const ASSIGNMENT_KEY="assignment",OUTPUT_LOG$2="db.assignment.log";function setupDatabase$2(t){return ASSIGNMENT_KEY in t||(t[ASSIGNMENT_KEY]=new Map),t}function getAssignmentByID(t,e,r){return t[ASSIGNMENT_KEY].get(e)[r]}function getAssignmentsByUser(t,e){return Object.keys(t[ASSIGNMENT_KEY].get(e))}function outputLog$2(t,e="."){const r=t[ASSIGNMENT_KEY],n={};for(const[t,e]of r.entries())n[t]=e;const s=`${`${"# ".repeat(20)}\n# Assignments\n# Size: ${r.size}\n${"# ".repeat(20)}`}\n${JSON.stringify(n,null,4)}`;require("fs").writeFileSync(require("path").resolve(e,OUTPUT_LOG$2),s)}const REVIEW_KEY="review",OUTPUT_LOG$3="db.review.log";function setupDatabase$3(t){return REVIEW_KEY in t||(t[REVIEW_KEY]=new Map),t}function outputLog$3(t,e="."){const r=t[REVIEW_KEY],n={};for(const[t,e]of r.entries())n[t]=e;const s=`${`${"# ".repeat(20)}\n# Reviews\n# Size: ${r.size}\n${"# ".repeat(20)}`}\n${JSON.stringify(n,null,4)}`;require("fs").writeFileSync(require("path").resolve(e,OUTPUT_LOG$3),s)}const VACATION_KEY="vacation",OUTPUT_LOG$4="db.vacation.log";function setupDatabase$4(t){return VACATION_KEY in t||(t[VACATION_KEY]=new Map),t}function outputLog$4(t,e="."){const r=t[VACATION_KEY],n={};for(const[t,e]of r.entries())n[t]=e;const s=`${`${"# ".repeat(20)}\n# Vacations\n# Size: ${r.size}\n${"# ".repeat(20)}`}\n${JSON.stringify(n,null,4)}`;require("fs").writeFileSync(require("path").resolve(e,OUTPUT_LOG$4),s)}async function setupDatabase$5(t){const e=createDatabase();let r;return r="currentDate"in t?parseAmericanDate(t.currentDate):new Date(Date.now()),e.currentDate=r,setupDatabase(e),setupDatabase$1(e),setupDatabase$2(e),setupDatabase$3(e),setupDatabase$4(e),e}async function createDatabase$1(t){return console.log("...Creating database..."),await setupDatabase$5(t)}async function loadDatabaseFromInputs(t,e){console.log("...Load database from inputs...");const r=await findInputEntries(e);for(const n of r)try{await loadInputEntry(t,e,n)}catch(t){console.error("Failed to load input entry.",t)}}async function verifyDatabaseWithClient(t,e){return console.log("...Verifying database with client..."),await askWhetherDatabaseIsValidToUse()}async function findDatabaseErrors(t,e){console.log("...Finding database errors...")}async function shouldContinueResolvingErrorsWithClient(t,e,r){console.log("...Should resolve database errors?")}async function resolveDatabaseErrors(t,e,r){console.log("...Resolving database errors...")}async function verifyErrorsWithClient(t,e,r){if(!r||r.length<=0)return!0}async function outputErrorLog(t,e,r){console.log("...Outputting database errors...")}const IDENTITY=function(t){return t};class TableBuilder{constructor(){this.entries=[],this.columns=[]}addEntry(...t){this.entries.push(t)}addColumn(t,e=IDENTITY){this.columns.push({header:t,data:e})}build(){const t=[];for(const e of this.columns)t.push(e.header);const e=[];e.push(t);for(const t of this.entries){const r=[];for(const e of this.columns){const n=e.data.apply(null,t);r.push(n)}e.push(r)}return e}}const path$2=require("path");async function output(t,e,r,n){const s=new TableBuilder;s.addColumn("User ID"),s.addColumn("Name",e=>getUserByID(t,e).name),s.addColumn("Used Slips",e=>getUserByID(t,e).attributes.slips.used),s.addColumn("Remaining Slips",e=>getUserByID(t,e).attributes.slips.remaining),s.addColumn("Average Slips (Median)",e=>getUserByID(t,e).attributes.slips.median),s.addColumn("Max Slips",e=>getUserByID(t,e).attributes.slips.max),s.addColumn("Missing Assignments",e=>getUserByID(t,e).attributes.progress.missing),s.addColumn("Auto-report",e=>{let r=!1;const n=getUserByID(t,e).attributes;return n.slips.mean*(n.progress.missing+n.progress.unassigned)>n.slips.max&&(r=!0),r?"NOTICE!":"N/A"});const o=new Set;for(const e of getUsers(t)){const r=getAssignmentsByUser(t,e);for(const n of r)if(!o.has(n)){"_"!==getAssignmentByID(t,e,n).attributes.status&&o.add(n)}}const a=Array.from(o).reverse();for(const e of a)s.addColumn(e+" Status",r=>{const n=getAssignmentByID(t,r,e);return n?n.attributes.status:"!ERROR"}),s.addColumn(e+" Slips",r=>{const n=getAssignmentByID(t,r,e);return n?n.attributes.slipDays:"!ERROR"});for(const e of getUsers(t))s.addEntry(e);writeTableToCSV(r,s.build())}var InstructorReportOutput=Object.freeze({output:output});const path$3=require("path");function stringifyStatus(t,e=0){let r,n,s;switch(r="N"===t&&e>0?"+?":"",n=e>0?` (${e}${r} slip day(s) used)`:"",t){case"Y":s="Completed";break;case"N":s="Missing";break;case"_":s="Not yet assigned";break;default:s="Unknown"}return s+n}function generateProgressReport(t,e){const r=getUserByID(t,e),n=[];n.push("Name: "+r.name),n.push("PID: "+r.attributes.pid),n.push("Date: "+t.currentDate.toDateString()),n.push(""),n.push("Your weekly student report:");const s=getAssignmentsByUser(t,e),o=[],a=[];let i=0,u=0;for(const r of s){const s=getAssignmentByID(t,e,r);"N"===s.attributes.status?(a.push(s),u+=1):"?"===s.attributes.status&&o.push(s),i+=s.attributes.slipDays,n.push(s.id+" - "+stringifyStatus(s.attributes.status,s.attributes.slipDays))}n.push("");const c=calculateNumberOfSlipDays(r.schedule);return n.push("Daily accruing slip days:"+u),n.push("Remaining slip days available:"+(c-i)),n.push(""),a.length>0&&(n.push("IMPORTANT:"),n.push(""),n.push("Missing assignment for "+a.map(t=>t.id).join(", ")+"."),n.push(""),n.push("You must turn in all assignments, even if late. These will continue to accrue slip-days until it is turned in."),n.push("")),o.length>0&&n.push("*In-Review: Significant difference has been found for the submission for the week past the deadline. A review is being conducted to evaluate number slip days used. Until resolved, it will assume the latest submission time is accurate."),n.push(""),'"'+n.join("\n")+'"'}function generateNoticeReport(t,e){return"N/A"}async function output$1(t,e,r,n){const s=new TableBuilder;s.addColumn("User ID"),s.addColumn("User Name",e=>getUserByID(t,e).name),s.addColumn("Progress Report",e=>generateProgressReport(t,e)),s.addColumn("Notice Report",t=>generateNoticeReport());for(const e of getUsers(t))s.addEntry(e);writeTableToCSV(r,s.build())}var StudentReportOutput=Object.freeze({output:output$1});const path$4=require("path");async function output$2(t,e,r,n){let s;if(outputLog(t,r),outputLog$1(t,r),outputLog$2(t,r),outputLog$3(t,r),outputLog$4(t,r),writeToFile(path$4.resolve(r,"config.log"),JSON.stringify(e,null,4)),t.getErrors().length<=0)s="HOORAY! No errors!";else{let e=[];for(const r of t.getErrors())e.push(`${r.id}: [${r.tag}] ${r.message}\n=== SOLUTIONS: ===\n => ${r.options.join("\n => ")}\n=== MOREINFO: ===\n${r.more.join("\n")}\n`);s="It's okay. We'll get through this.\n\n"+e.join("\n")}writeToFile(path$4.resolve(r,"errors.txt"),s)}var DebugReportOutput=Object.freeze({output:output$2});const path$5=require("path");function findOutputEntries(t){return console.log("...Finding output entries..."),Array.isArray(t.outputs)?t.outputs:[]}async function processOutputEntry(t,e,r){console.log("...Process output entry...");const n=e.outputPath,s=r.outputName,o=path$5.resolve(n,s),a=r.format,i=r.customFormatPath,u=r.opts;let c;if(i)try{if("function"!=typeof(c=require(i)).output)throw new Error(`Invalid custom format '${i}' - must export named function 'output'.`)}catch(t){throw new Error(`Cannot load custom format from '${i}'.`,t)}else switch(a){case"instructor":c=InstructorReportOutput;break;case"student":c=StudentReportOutput;break;case"debug":c=DebugReportOutput;default:throw new Error(`Cannot find valid output of type '${a}'.`)}await c.output(t,e,o,u)}const DIRECTORY=".";async function main(t){try{const t=await resolveConfig(DIRECTORY);console.log(t);const e=await resolveDatabase(t);console.log(e),await validateDatabase(e,t),await generateOutput(e,t)}catch(t){return console.error("Program failed.",t),!1}return!0}async function resolveConfig(t){let e;console.log("Resolving config...");try{e=await loadConfigFile(t)}catch(t){let r;for(;r=await requestConfigFile();)try{if(e=await loadConfigFile(r))break}catch(t){console.error("Failed to load config.",t)}e||(e=await loadDefaultConfig())}if(!e)throw new Error("Could not resolve a config file for program. Stopping program...");return e}async function resolveDatabase(t){console.log("Resolving database...");const e=await createDatabase$1(t);if(await loadDatabaseFromInputs(e,t),!await verifyDatabaseWithClient())throw new Error("Could not resolve database for program. Please update the config to match your specifications, then try again. Stopping program...");return e}async function validateDatabase(t,e){let r;for(console.log("Validating database...");(r=await findDatabaseErrors())&&await shouldContinueResolvingErrorsWithClient();)await resolveDatabaseErrors();if(!await verifyErrorsWithClient(t,e,r))throw await outputErrorLog(),new Error("Could not validate database. Stopping program...")}async function generateOutput(t,e){console.log("Generating output...");const r=findOutputEntries(e);for(const n of r)try{await processOutputEntry(t,e,n)}catch(t){console.error("Failed to process output entry.",t)}}main(process.argv).then(t=>{t?console.log("Success!"):console.log("Failure!")});
